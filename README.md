前端后台参数传递
服务端框架
熟悉面向对象的分析设计和工具
虚函数实现：通过虚函数表和虚指针。
C++ 抽象类 含有纯虚函数的类，抽象类不能使用new出对象，只有实现了这个纯虚函数的子类才能new出对象。
纯虚函数：无函数体
虚函数：有函数体，C++的虚函数主要作用是“运行时多态”，父类中提供虚函数的实现，为子类提供默认的函数实现。
多态：当一个类需要表现出多种形态，具有多种实现方式。避免了在父类里大量重载引起代码臃肿且难于维护，增强程序的可扩展性及可维护性，使代码更加简洁。子类重写父类的方法。使子类具有不同的方法实现。
重写：如果在子类中定义的一个方法，其名称、返回类型及参数列表正好与父类中某个方法的名称、返回类型及参数列表相匹配，那么可以说，子类的方法重写了父类的方法。
重载：多个同名而不同参数的方法之间，互相称之为重载方法。

事物的特性
1.原子性：不可在细分，要么执行，要么不执行
2.一致性：主要针对数据库，事物执行成功则数据库变更，失败不变更。
3.隔离性：事物之间可以同时执行，事物之间是隔离的
4.持续性：事物一旦执行成功，执行之后的结果是持续的

数据库连接查询Join：
概念：根据两个表或多个表的列之间的关系，从这些表中查询数据。
目的：实现多个表查询操作
内连接(INNER JOIN（JOIN）)：  
    定义：仅将两个表中满足连接条件的行组合起来作为结果集。
在内连接中，只有在两个表中匹配的行才能在结果集中出现
关键词：INNER JOIN
格式：
SELECT 列名表 FROM 表名1 [INNER] JOIN 表名2 ON或WHERE 条件表达式   
外连接(OUTER JOIN)：  
    分为三种：  
左外连接(LEFT OUTER JOIN或LEFT JOIN) 、右外连接(RIGHT JOIN)  、全外连接(FULL JOIN)     {影响显示方式}
左连接where只影向右边表，右连接where只影响左边表。完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。
	select * from tbl1 Left Join tbl2 where tbl1.ID = tbl2.ID
左连接后的检索结果是显示tbl1的所有数据和tbl2中满足where 条件的数据    
交叉连接(CROSS JOIN)：  
    没有WHERE 子句，它返回连接表中所有数据行的笛卡尔积 。

Oracle和MySQL区别：
1、语法方面：连接方式Oracle用+表示，Mysql用join关键字。
2、数据持久性方面：Oracle保证提交的数据均可恢复，因为oracle把提交的sql操作线写入了在线联机日志文件中，保持到了磁盘上，如果出现数据库或主机异常重启，重启后oracle可以考联机在线日志恢复客户提交的数据。Mysql默认提交sql语句，但如果更新过程中出现db或主机重启的问题，也许会丢失数据。
3、提交方式：oracle默认不自动提交，需要用户手动提交。mysql默认是自动提交。
4、逻辑备份：oracle逻辑备份时不锁定数据，且备份的数据是一致的。mysql逻辑备份时要锁定数据，才能保证备份的数据是一致的，影响业务正常的dml使用（不支持热备份）。
5、并发性：mysql以表级锁为主，对资源锁定的粒度很大，如果一个session对一个表加锁时间过长，会让其他session无法更新此表中的数据。oracle使用行级锁，对资源锁定的粒度要小很多，只是锁定sql需要的资源，并且加锁是在数据库中的数据行上，不依赖与索引。所以oracle对并发性的支持要好很多。

树：
二叉排序树：
1、若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
2、若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
3、左、右子树也分别为二叉排序树；
4、没有键值相等的节点

平衡二叉树（AVL）基于二叉排序树：
1、它的左子树和右子树都是平衡二叉树，
2、左子树和右子树的深度之差的绝对值不超过1。

红黑树：
1、节点是红色或黑色。
2、根是黑色。
3、所有叶子都是黑色（叶子是NIL节点）。
4、每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
5、从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。
B树B+树

Xen和Kvm：
Xen支持全虚拟和半虚拟，kvm支持全虚拟
Xen不能够根据内核升级而升级，需要补丁升级。

排序算法：
(1)冒泡排序
冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。

(2)选择排序
选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n – 1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。

(3)插入排序 
插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。

(4)快速排序 
快速排序有两个方向，左边的i下标一直往右走，当a[i] <= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] > a[center_index]。如果i和j都走不动了，i <= j，交换a[i]和a[j],重复上面的过程，直到i > j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。

(5)归并排序 
归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。

(6)基数排序 
基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。

(7)希尔排序(shell) 
希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。

(8)堆排序 
我们知道堆的结构是节点i的孩子为2 * i和2 * i + 1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n / 2开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为n / 2 – 1， n / 2 – 2， … 1这些个父节点选择元素时，就会破坏稳定性。有可能第n / 2个父节点交换把后面一个元素交换过去了，而第n / 2 – 1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。



